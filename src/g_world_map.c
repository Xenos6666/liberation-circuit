/*

World background generation etc code

Functions in this file fill out the map_init struct with things for the g_world_map_2 code to turn into w and w_init

*/
#include <allegro5/allegro.h>

#include <stdio.h>
#include <math.h>


#include "m_config.h"
#include "m_globvars.h"

#include "g_header.h"

#include "g_misc.h"

#include "m_maths.h"
//#include "i_disp_in.h"
//#include "i_background.h"
//#include "s_menu.h"
#include "g_world_back.h"
#include "g_world_map.h"
#include "g_world_map_2.h"
#include "h_mission.h"
#include "h_story.h"

extern struct world_init_struct w_init; // this is the world_init generated by world setup menus - declared in s_menu.c
struct map_init_struct map_init;



void reset_map_init(int map_size_blocks,
																				int map_area,
																				int players);
static void place_player_on_map_init(int player_index, int spawn_x, int spawn_y, int flip_x, int flip_y);
static void set_player_map_init_spawn_angle(int player_index, int nearby_data_well);
void generate_scattered_map(int area_index,
																												int size_blocks,
																					       int players,
																					       unsigned int map_seed);
static int check_map_gen_state_data_well_position(int block_x, int block_y);
void set_player_spawn_position_by_specified_well(int player_index, int well_index, int angle_from_well, int distance_from_well);
static int new_mdetail(int mdetail_type);


// resets back_init to a basic default state
// map_size_blocks should be based on call to fix_w_init_size();
void reset_map_init(int map_size_blocks,
																				int map_area,
																				int players)
{
 int i;

 for (i = 0; i < MDETAILS; i ++)
	{
		map_init.mdetail[i].type = MDETAIL_NONE;
	}

	map_init.area_index = map_area;

// map_init.base_background_depth = BACKBLOCK_LAYERS - 1;
// map_init.background_depth_random_add = 0; // size of random addition
// map_init.background_depth_random_sub = 0; // size of random subtraction

 switch(map_area)
 {
 	default:
 	case AREA_BLUE:
   map_init.background_size_base = 11;
   map_init.background_size_random = 5;
   map_init.background_size_random_freq = 50;//20;//60; // frequency of random addition/subtraction to background depth
   break;
 	case AREA_YELLOW:
   map_init.background_size_base = 11;
   map_init.background_size_random = 12;
   map_init.background_size_random_freq = 80;//20;//60; // frequency of random addition/subtraction to background depth
   break;
 	case AREA_RED:
   map_init.background_size_base = 11;
   map_init.background_size_random = 12;
   map_init.background_size_random_freq = 90;//20;//60; // frequency of random addition/subtraction to background depth
   break;
 }
// map_init.background_size_random_freq = 2; // frequency of random addition/subtraction to background size
// map_init.background_size_random_add = 5; // size of random addition
// map_init.background_size_random_sub = 5; // size of random subtraction

 map_init.map_size_blocks = map_size_blocks;
 map_init.players = players;

 map_init.data_wells = 0;

 map_init.general_background_type = BACKGROUND_TYPE_NOISE;
// map_init.data_well_style = map_area;
/*
 map_init.base_background_size = 16;
 map_init.background_size_random_add = 6;
 map_init.background_size_random_sub = 3;
 map_init.background_size_random_freq = 70; // percent?
 map_init.base_background_depth = 3;
 map_init.background_depth_random_add = 0;
 map_init.background_depth_random_sub = 1;
 map_init.background_depth_random_freq = 50; // percent?
*/
}


void generate_random_map(int area_index,
																									int size_blocks,
																					    int players,
																					    unsigned int map_seed)
{

// map_seed needs to be the value originally passed to this function,
//  because the generate_* functions can be called directly
//  (I think? maybe)

// int area_index = (map_seed % (STORY_AREAS - 1)) + 1; // AREA_BLUE to AREA_RED (not AREA_TUTORIAL)

 generate_scattered_map(area_index, size_blocks, players, map_seed);

 generate_map_from_map_init();

}





// this structure is used during some kinds of map creation
//  to store details about player 0's area of the map, which
//  may then be copied to other parts of the map for symmetry
struct map_gen_state_struct
{

 int base_data_wells;
 int base_data_well_x [DATA_WELLS];
 int base_data_well_y [DATA_WELLS];
 int base_data_well_reserve_data [DATA_WELLS] [DATA_WELL_RESERVES];
 int base_data_well_reserve_squares [DATA_WELLS];
 float base_data_well_spin [DATA_WELLS];

 int base_spawn_position_x;
 int base_spawn_position_y;

};

struct map_gen_state_struct map_gen_state;


// sets up map_init with details for a map randomly scattered with data wells.
void generate_scattered_map(int area_index,
																												int size_blocks,
																					       int players,
																					       unsigned int map_seed)
{

//fpr("\n gsm area %i size %i [%i] pl %i [%i] ms %i", area_index, size_blocks, w_init.map_size_blocks, players, w_init.players, map_seed);

	seed_mrand(map_seed);

 reset_map_init(size_blocks,
																area_index,
																players);


 map_gen_state.base_data_wells = 0;

#define DATA_WELL_EDGE_DISTANCE 12
#define DATA_WELL_SEPARATION 12

 int base_min_x = DATA_WELL_EDGE_DISTANCE;
 int base_min_y = DATA_WELL_EDGE_DISTANCE;
 int base_max_x;
 int base_max_y;
 int total_base_data_wells;
 int base_var_x;
 int base_var_y;
 int symmetry_mode = 0; // currently only used for 2 players


 switch(w_init.players)
 {
 	default:
 	 case 2:
 	 	total_base_data_wells = 2 + mrand(DATA_WELLS / 2 - 2);
    symmetry_mode = mrand(4);
    if (symmetry_mode < 2) // left/right
				{
 	 	 base_max_x = (map_init.map_size_blocks / 2) - DATA_WELL_EDGE_DISTANCE;
 	 	 base_max_y = map_init.map_size_blocks - base_min_y;
     base_var_x = base_max_x - base_min_x;
     base_var_y = base_max_y - base_min_y;
     map_gen_state.base_spawn_position_x = base_min_x + mrand((base_var_x / 3) * 2);
     map_gen_state.base_spawn_position_y = base_min_y + mrand(base_var_y - 4);
				}
				 else // up/down
					{
 	 	  base_max_x = map_init.map_size_blocks - base_min_x;
 	 	  base_max_y = (map_init.map_size_blocks / 2) - DATA_WELL_EDGE_DISTANCE;
      base_var_x = base_max_x - base_min_x;
      base_var_y = base_max_y - base_min_y;
      map_gen_state.base_spawn_position_x = base_min_x + mrand(base_var_x - 4);
      map_gen_state.base_spawn_position_y = base_min_y + mrand((base_var_y / 3) * 2);
					}
 	 	break;
 	 case 3:
 	 	base_max_x = (map_init.map_size_blocks / 2) - DATA_WELL_EDGE_DISTANCE;
 	 	base_max_y = (map_init.map_size_blocks / 2) - DATA_WELL_EDGE_DISTANCE;
 	 	total_base_data_wells = 2 + mrand(DATA_WELLS / 3 - 1);
    base_var_x = base_max_x - base_min_x;
    base_var_y = base_max_y - base_min_y;
    map_gen_state.base_spawn_position_x = base_min_x + mrand((base_var_x / 3) * 2);
    map_gen_state.base_spawn_position_y = base_min_y + mrand((base_var_y / 3) * 2);
 	 	break;
 	 case 4:
 	 	base_max_x = (map_init.map_size_blocks / 2) - DATA_WELL_EDGE_DISTANCE;
 	 	base_max_y = (map_init.map_size_blocks / 2) - DATA_WELL_EDGE_DISTANCE;
 	 	total_base_data_wells = 2 + mrand(DATA_WELLS / 4 - 1);
    base_var_x = base_max_x - base_min_x;
    base_var_y = base_max_y - base_min_y;
    map_gen_state.base_spawn_position_x = base_min_x + mrand((base_var_x / 3) * 2);
    map_gen_state.base_spawn_position_y = base_min_y + mrand((base_var_y / 3) * 2);
 	 	break;
 }


// now place the initial data well next to the spawn point:
	map_gen_state.base_data_well_x [0] = map_gen_state.base_spawn_position_x;
	map_gen_state.base_data_well_y [0] = map_gen_state.base_spawn_position_y;

 if (map_gen_state.base_spawn_position_x < base_min_x + 4)
		map_gen_state.base_data_well_x [0] = map_gen_state.base_spawn_position_x + 4;
		 else
			{
    if (map_gen_state.base_spawn_position_y < base_min_y + 4)
		   map_gen_state.base_data_well_y [0] = map_gen_state.base_spawn_position_y + 4;
		    else
						{
       if (map_gen_state.base_spawn_position_y > base_max_y - 5)
		      map_gen_state.base_data_well_y [0] = map_gen_state.base_spawn_position_y - 4;
		       else
									{
										// default position (if not near any other edge edge) is to put data well to left of spawn position:
		        map_gen_state.base_data_well_x [0] = map_gen_state.base_spawn_position_x - 4;
									}
						}
			}

// if (mrand(6) != 0)
	{
  map_gen_state.base_data_well_reserve_data [map_gen_state.base_data_wells] [0] = 1500;
  map_gen_state.base_data_well_reserve_data [map_gen_state.base_data_wells] [1] = 1000;
  map_gen_state.base_data_well_reserve_squares [map_gen_state.base_data_wells] = 4;
  map_gen_state.base_data_well_spin [map_gen_state.base_data_wells] = 0.003; // okay to use float as this doesn't affect anything
	}

 map_gen_state.base_data_wells = 1;

 int attempt_counter = 0;

 while (map_gen_state.base_data_wells < total_base_data_wells)
	{
		while(TRUE)
		{
			int new_block_x = base_min_x + mrand(base_var_x);
			int new_block_y = base_min_y + mrand(base_var_y);
		 if (abs(new_block_x - map_gen_state.base_spawn_position_x) >= 8
				|| abs(new_block_y - map_gen_state.base_spawn_position_y) >= 8)
		 {

				 	if (check_map_gen_state_data_well_position(new_block_x, new_block_y))
						{

       map_gen_state.base_data_well_x [map_gen_state.base_data_wells] = new_block_x;
       map_gen_state.base_data_well_y [map_gen_state.base_data_wells] = new_block_y;
       map_gen_state.base_data_well_reserve_data [map_gen_state.base_data_wells] [0] = 500 + mrand(1000);
       map_gen_state.base_data_well_reserve_data [map_gen_state.base_data_wells] [1] = 500 + mrand(1000);
       map_gen_state.base_data_well_reserve_squares [map_gen_state.base_data_wells] = 2 + mrand(4);
       map_gen_state.base_data_well_spin [map_gen_state.base_data_wells] = 0.002 + mrand(10) * 0.0001; // okay to use float as this doesn't affect anything
	      if (mrand(2))
		      map_gen_state.base_data_well_spin [map_gen_state.base_data_wells] *= -1;

							map_gen_state.base_data_wells ++;
							attempt_counter = 0;
							break; // out of while(TRUE) loop
						}
		 }

  			attempt_counter ++;

			if (attempt_counter > 1000) // unlikely but let's check anyway (could happen on small 4 player maps, I guess)
 			break;
		}; // end while(TRUE) loop
		if (attempt_counter > 1000)
			break;
	} // end for i data wells loop



 switch(map_init.players)
 {
 	default: // should never happen
 	case 2:
   place_player_on_map_init(0, map_gen_state.base_spawn_position_x, map_gen_state.base_spawn_position_y, 1, 1);
   switch(symmetry_mode)
   {
   	case 0: // left/right mirror
     place_player_on_map_init(1, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_gen_state.base_spawn_position_y, -1, 1);
     break;
    case 1: // L/R rotation
     place_player_on_map_init(1, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, -1, -1);
					break;
    case 2: // U/D mirror
     place_player_on_map_init(1, map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, 1, -1);
     break;
    case 3: // U/D rotation
     place_player_on_map_init(1, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, -1, -1);
     break;
   }
   break;
 	case 3:
// for now, 3-player maps are just 4-player maps with one player missing
   {
   	int missing_position = mrand(4);
   	int player_index = 0;
   	if (missing_position != 0)
     place_player_on_map_init(player_index++, map_gen_state.base_spawn_position_x, map_gen_state.base_spawn_position_y, 1, 1);
   	if (missing_position != 1)
     place_player_on_map_init(player_index++, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_gen_state.base_spawn_position_y, -1, 1);
   	if (missing_position != 2)
     place_player_on_map_init(player_index++, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, -1, -1);
   	if (missing_position != 3)
     place_player_on_map_init(player_index++, map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, 1, -1);
   }
   break;
 	case 4:
// for now, 4-player maps are always mirrored (implement rotation later)
   place_player_on_map_init(0, map_gen_state.base_spawn_position_x, map_gen_state.base_spawn_position_y, 1, 1);
   place_player_on_map_init(1, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_gen_state.base_spawn_position_y, -1, 1);
   place_player_on_map_init(2, map_init.map_size_blocks - map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, -1, -1);
   place_player_on_map_init(3, map_gen_state.base_spawn_position_x, map_init.map_size_blocks - map_gen_state.base_spawn_position_y, 1, -1);
   break;
 }


}


// This function is used only for map generation functions that use map_gen_state. Otherwise, use set_player_spawn_position_by_well or something like that
// flip values should be 1 for no flip, -1 for flip
// spawn angle is determined by position of nearby data well.
static void place_player_on_map_init(int player_index, int spawn_x, int spawn_y, int flip_x, int flip_y)
{

	map_init.spawn_position [player_index].x = spawn_x;
	map_init.spawn_position [player_index].y = spawn_y;

	int i;

	for (i = 0; i < map_gen_state.base_data_wells; i ++)
	{
		int dw_x_offset = map_gen_state.base_data_well_x [i] - map_gen_state.base_spawn_position_x;
		int dw_y_offset = map_gen_state.base_data_well_y [i] - map_gen_state.base_spawn_position_y;
		int base_data_well_index = map_init.data_wells - (map_gen_state.base_data_wells * player_index);
		map_init.data_well_position [map_init.data_wells].x = spawn_x + (dw_x_offset * flip_x);
		map_init.data_well_position [map_init.data_wells].y = spawn_y + (dw_y_offset * flip_y);
		map_init.data_well_reserve_data [map_init.data_wells] [0] = map_gen_state.base_data_well_reserve_data [base_data_well_index] [0];
		map_init.data_well_reserve_data [map_init.data_wells] [1] = map_gen_state.base_data_well_reserve_data [base_data_well_index] [1];
		map_init.data_well_reserve_squares [map_init.data_wells] = map_gen_state.base_data_well_reserve_squares [base_data_well_index];
		map_init.data_well_spin_rate [map_init.data_wells] = map_gen_state.base_data_well_spin [base_data_well_index];
		if (player_index & 1)
			map_init.data_well_spin_rate [map_init.data_wells] *= -1;

// process 0's spawn angle should point directly away from the nearby data well:

		map_init.spawn_angle [player_index] = get_angle_int(map_init.spawn_position [player_index].y - map_init.data_well_position [map_init.data_wells].y,
																																																				  map_init.spawn_position [player_index].x - map_init.data_well_position [map_init.data_wells].x);

		if (i == 0)
   set_player_map_init_spawn_angle(player_index, map_init.data_wells);

		map_init.data_wells ++;

	}

}


static void set_player_map_init_spawn_angle(int player_index, int nearby_data_well)
{
//fpr("\n spmisa %i,%i", player_index, nearby_data_well);
	al_fixed spawn_x = block_to_fixed(map_init.spawn_position[player_index].x) + BLOCK_SIZE_FIXED / 2;
	al_fixed spawn_y = block_to_fixed(map_init.spawn_position[player_index].y) + BLOCK_SIZE_FIXED / 2;
	al_fixed well_x = block_to_fixed(map_init.data_well_position[nearby_data_well].x) + BLOCK_SIZE_FIXED / 2;
	al_fixed well_y = block_to_fixed(map_init.data_well_position[nearby_data_well].y) + BLOCK_SIZE_FIXED / 2;

	map_init.spawn_angle [player_index] = fixed_angle_to_int(get_angle(spawn_y - well_y, spawn_x - well_x));

}

// Call this to set a player's spawn position to near the latest well in the map_init structure,
//  and a particular angle from that well.
// Is called from s_mission.c (from which map_init may not be accessible - not sure)
void set_player_spawn_position_by_latest_well(int player_index, int angle_from_well, int distance_from_well)
{

#ifdef SANITY_CHECK
 if (map_init.data_wells <= 0)
	{
		fpr("\n Error: g_world_map.c: set_player_spawn_position_by_latest_well(): no wells yet.");
		error_call();
	}
#endif

	set_player_spawn_position_by_specified_well(player_index, map_init.data_wells - 1, angle_from_well, distance_from_well);

}

void set_player_spawn_position_by_specified_well(int player_index, int well_index, int angle_from_well, int distance_from_well)
{

	al_fixed well_x = block_to_fixed(map_init.data_well_position[well_index].x) + BLOCK_SIZE_FIXED / 2;
	al_fixed well_y = block_to_fixed(map_init.data_well_position[well_index].y) + BLOCK_SIZE_FIXED / 2;

	al_fixed spawn_x = well_x + fixed_xpart(int_angle_to_fixed(angle_from_well), al_itofix(distance_from_well));
	al_fixed spawn_y = well_y + fixed_ypart(int_angle_to_fixed(angle_from_well), al_itofix(distance_from_well));

	map_init.spawn_position[player_index].x = fixed_to_block(spawn_x);
	map_init.spawn_position[player_index].y = fixed_to_block(spawn_y);

	map_init.spawn_angle [player_index] = angle_from_well;


}


void add_extra_spawn_by_latest_well(int player_index, int template_index, int angle_from_well)
{

#ifdef SANITY_CHECK
 if (map_init.data_wells <= 0)
	{
		fpr("\n Error: g_world_map.c: set_player_spawn_position_by_latest_well(): no wells yet.");
		error_call();
	}
#endif

 int well_index = map_init.data_wells - 1;

	al_fixed well_x = block_to_fixed(map_init.data_well_position[well_index].x) + BLOCK_SIZE_FIXED / 2;
	al_fixed well_y = block_to_fixed(map_init.data_well_position[well_index].y) + BLOCK_SIZE_FIXED / 2;

	int spawn_block_x = fixed_to_block(well_x + fixed_xpart(int_angle_to_fixed(angle_from_well), al_itofix(512)));
	int spawn_block_y = fixed_to_block(well_y + fixed_ypart(int_angle_to_fixed(angle_from_well), al_itofix(512)));

	add_extra_spawn(player_index, template_index, spawn_block_x, spawn_block_y, angle_from_well);

}

block_cart get_well_block_position(int well_index)
{

	block_cart return_position;

	return_position.x = map_init.data_well_position[well_index].x;
	return_position.y = map_init.data_well_position[well_index].y;

	return return_position;


}

void set_player_spawn_position(int player_index, int block_x, int block_y, int angle)
{

	  map_init.spawn_position[player_index].x = block_x;
	  map_init.spawn_position[player_index].y = block_y;
	  map_init.spawn_angle [player_index] = angle;

}

// returns 0 if location is too close to an existing data well, 1 if not.
static int check_map_gen_state_data_well_position(int block_x, int block_y)
{
     	int i;

				 	for (i = 0; i < map_gen_state.base_data_wells; i ++)
						{
		     if (abs(block_x - map_gen_state.base_data_well_x [i]) < DATA_WELL_SEPARATION
				    && abs(block_y - map_gen_state.base_data_well_y [i]) < DATA_WELL_SEPARATION)
				   {
				   	return 0;
  		   }
						}

	return 1;

}


// returns number of data well just placed, in case it's useful
int add_data_well_to_map_init(int x, int y, int reserve_A, int reserve_B, int reserve_squares, float spin_rate)
{

	#ifdef SANITY_CHECK
 if (map_init.data_wells >= DATA_WELLS)
	{
		fpr("\nError: s_mission.c: add_data_well_to_map_init(): too many data wells");
		error_call();
	}
#endif

 map_init.data_well_position [map_init.data_wells].x = x;
 map_init.data_well_position [map_init.data_wells].y = y;
 map_init.data_well_reserve_data [map_init.data_wells] [0] = reserve_A;
 map_init.data_well_reserve_data [map_init.data_wells] [1] = reserve_B;
 map_init.data_well_reserve_squares [map_init.data_wells] = reserve_squares;
 map_init.data_well_spin_rate [map_init.data_wells] = spin_rate;

 map_init.data_wells ++;

 return map_init.data_wells - 1;

}

// returns mdetail number
int add_mdetail_ring(int centre_x, int centre_y, int ring_size, int empty_centre)
{

	int md_type = MDETAIL_RING;
	if (empty_centre)
		md_type = MDETAIL_RING_EMPTY;
	int mdetail_index = new_mdetail(md_type);

	map_init.mdetail[mdetail_index].block_position.x = centre_x;
	map_init.mdetail[mdetail_index].block_position.y = centre_y;
	map_init.mdetail[mdetail_index].dsize = ring_size;

	return mdetail_index;

}

// returns mdetail number
int add_mdetail_line(int start_x, int start_y, int end_x, int end_y, int line_thickness)
{

	int md_type = MDETAIL_LINE;
	int mdetail_index = new_mdetail(md_type);

	map_init.mdetail[mdetail_index].block_position.x = start_x;
	map_init.mdetail[mdetail_index].block_position.y = start_y;
	map_init.mdetail[mdetail_index].block_position2.x = end_x;
	map_init.mdetail[mdetail_index].block_position2.y = end_y;
	map_init.mdetail[mdetail_index].dsize = line_thickness;

	return mdetail_index;

}

// returns mdetail number
int add_mdetail_system(int centre_x, int centre_y, int system_size)
{

	int md_type = MDETAIL_SYSTEM_CLEAR;
	int mdetail_index = new_mdetail(md_type);

	map_init.mdetail[mdetail_index].block_position.x = centre_x;
	map_init.mdetail[mdetail_index].block_position.y = centre_y;
	map_init.mdetail[mdetail_index].dsize = system_size;

	return mdetail_index;

}


// returns mdetail number
int add_mdetail_worm_source(int centre_x, int centre_y, int worms)
{

	int md_type = MDETAIL_WORM_SOURCE;
	int mdetail_index = new_mdetail(md_type);

	map_init.mdetail[mdetail_index].block_position.x = centre_x;
	map_init.mdetail[mdetail_index].block_position.y = centre_y;
	map_init.mdetail[mdetail_index].dsize = worms;

	return mdetail_index;

}


void add_mdetail_worm_source_to_all_wells(void)
{


	int i;
	int worms;

	for (i = 0; i < map_init.data_wells; i ++)
	{
		worms = 15;
		worms += map_init.data_well_reserve_squares [i] * 3;
		if (map_init.data_well_reserve_data [i] [0] > 0
			&& map_init.data_well_reserve_data [i] [1] > 0)
				worms += 5;

		add_mdetail_worm_source(map_init.data_well_position[i].x, map_init.data_well_position[i].y, worms);
	}

}

// adds a data well to an mdetail ring at a particular angle.
// returns the index of the data well.
int add_data_well_to_mdetail_ring(int mdetail_ring_index, int angle, int reserve_A, int reserve_B, int reserve_squares, float spin_rate)
{

#ifdef SANITY_CHECK
 if (mdetail_ring_index < 0
		|| (map_init.mdetail[mdetail_ring_index].type != MDETAIL_RING
			&& map_init.mdetail[mdetail_ring_index].type != MDETAIL_RING_EMPTY))
	{
		fpr("\n g_world_map.c: add_data_well_to_mdetail_ring(): failed (ring_index %i)", mdetail_ring_index);
	}
#endif

 al_fixed fixed_angle = int_angle_to_fixed(angle);
 int ring_size_pixels = (map_init.mdetail[mdetail_ring_index].dsize + 5) * BLOCK_SIZE_PIXELS;

	al_fixed well_x_fixed = block_to_fixed(map_init.mdetail[mdetail_ring_index].block_position.x) + fixed_xpart(fixed_angle, al_itofix(ring_size_pixels));
	al_fixed well_y_fixed = block_to_fixed(map_init.mdetail[mdetail_ring_index].block_position.y) + fixed_ypart(fixed_angle, al_itofix(ring_size_pixels));

	int well_x_block = fixed_to_block(well_x_fixed);
	int well_y_block = fixed_to_block(well_y_fixed);

 return add_data_well_to_map_init(well_x_block, well_y_block, reserve_A, reserve_B, reserve_squares, spin_rate);

}


// returns mdetail number
int	add_line_between_data_wells(int well_1, int well_2, int line_thickness)
{

	return add_mdetail_line(map_init.data_well_position [well_1].x,
																		       map_init.data_well_position [well_1].y,
                         map_init.data_well_position [well_2].x,
																		       map_init.data_well_position [well_2].y,
																		       line_thickness);

}

// returns number of next mdetail, or -1 if none left
//  - actually should probably be an error to use up all mdetails
static int new_mdetail(int mdetail_type)
{

	int i;

	for (i = 0; i < MDETAILS; i ++)
	{
		if (map_init.mdetail[i].type == MDETAIL_NONE)
		{
			map_init.mdetail[i].type = mdetail_type;
			return i;
		}
	}

// no empty space in array

#ifdef SANITY_CHECK
 fpr("\n Error: g_world_map.c: new_mdetail(): too many map details.");
 error_call();
#endif

 return -1;

}

/*

Plan for new ways to generate background:


Steps in generation:
 - decide where data wells will go
 - initialise background to default state
 - draw ripples/worms etc based on location of data wells
 - do other background stuff that should overwrite ripples/worms etc like paths between wells
 - place data wells and update background near them.

First step:
	- decide overall plan for map.
	- kinds of plans:
	 - central star
	  - a central data well plus other wells around it.
	  - player start positions are at some of the wells, which are linked to the centre too
		- side stars
		 - each player's part of the map has a star, and their start position is at one of the wells
		  - maybe the centre is joined too
	 - tree
	  - tree starts from a particular point
	   - either from centre towards start pos, or from start pos towards centre
			- then path splits each time

Will need:
- decide plan
- place all data wells
- decide default background type
-

Ways to place data wells:
 - randomly as now
 - star:
  - something (maybe a well) is at centre.
  - Other wells are arranged around that one in star shape - maybe random, maybe not.
  - path drawn between each well and the centre
 - polygons
  - like star, but nothing at centre and path is drawn between wells
	- void
	 - empty area with wells around the edge
	- path
	 - from each player's initial position to either a random end point or the centre
	 - or between two points e.g. between the edge of two rings
	 - possibility of multiple paths
	 - possibility of other approaches + paths

Ways to place player start positions:
	- This should basically

Also:
 - a new kind of thing called a "map detail" (mdetail) which causes changes to the background
   like a data well but has no gameplay consequences
    - although it may cause a "feature" to be created, which can prevent building


Also:
 - some features can remain as "features" (need a different data structure for this)
   which just prevent building nearby (and maybe do something in story missions)
    - with a special failure code for building there


Empty space:

Simple noise:
 - as now, but background all defaults to lowest depth. Place random small peaks/gaps all over the place.



Ripples
 - default depth is 2
 - each well has concentric rings around them that add to/subtract from base

worms
 - worms start from 6? points around each data well and move randomly from there. Maybe stop if intersect? And draw something there?



- any of them may reverse - default depth is high and features are low



Functions:

first, set everything up in the b_init struct
 - should contain:
  - default background depth and size
  - details of any randomness applied to default background depth

Make sure the b_init struct allows for features by not assuming every thing will be caused by wells.

*/


